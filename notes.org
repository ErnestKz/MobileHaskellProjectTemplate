Description of llvmng and bitcode and backend for haskell
https://mail.haskell.org/pipermail/ghc-devs/2017-September/014689.html

macOS where the mach-o format is used
the linker uses a feature called 'subsections_via_symbols' to strip dead code
- works by assuming all code bwteen two symbols belongs to the first symbol

stripper deletes the code of symbol if it determines the symbol is not used
so it deletes all the code below the symbol until the next symbol

ghc uses table next to code with 'prefixdata' in llvm feature which puts data before the symbol about the symbol

so cant strip any code produced by ghc on mac or macos

looks like the motivation for the llvmng and bitcode backend was make the binaries smaller.


** Mach-O
https://en.wikipedia.org/wiki/Mach-O


Talk about cross comp
https://www.youtube.com/watch?v=46A02obKt8g&list=PLbjcAmsCYuS4xspQb5BHnIHhi4BrWteGz&index=7

** Template Haskell
*** iserv-proxy and GHCSlave
- Need to acquire iserv-proxy program that runs on the build machine.
  - the iserv-proxy can be obtained from the ghc source tree.
  - within ghc/utils/remote-proxy
    - to build, need to run ./boot && ./configure <options> in ghc/
    - then go to ghc/utils/remote-proxy and then run make
    - this takes a long time

- Are there any caches available?
  - The dependency of remote-iserv on the main branch 9.3 is just libiserv
  - libiserv might be on hackage and therefore available in the nixpkgs cache
  - 9.0.1 is available https://hackage.haskell.org/package/libiserv
  - looks like libiserv comes with ghc, so maybe just need to get the 8.10.7 branch up
    - Correct that don't need to compile ghc, but looks like remote-proxy library depends on a module that doesn't exist.
      - i.e Remote.Message

  - So probably will need to look for a version of haskell that has a Remote.Message module.
    - Although libiserv does include the Remote.Message module, maybe cause I'm using nix?
      - Wasnt exactly cause of nix, the 
*** iserv
- need to cross compile iserv so that i have iserv-exe
  - cross compiler version is 8.4.0 but only 8.4.1 source distribution is available
  - run into an error where there is a missing header file, maybe the ghc 8.4.0 version doesn't ship with the header
    - had to change the path from a relative one to a absoulute one in /isrev/cbits/iservmain.c 
    
- Need to acquire GHCSlave program that runs on target.
  - https://github.com/zw3rk/ghc-slave
  - Doesn't look to much to build

 
** Haskell Build System
https://gitlab.haskell.org/ghc/ghc/-/wikis/building/architecture
https://gitlab.haskell.org/ghc/ghc/-/wikis/building/hadrian
https://gitlab.haskell.org/ghc/ghc/-/wikis/building/preparation
https://gitlab.haskell.org/ghc/ghc/blob/master/hadrian/doc/make.md
https://gitlab.haskell.org/ghc/ghc/-/blob/master/hadrian/README.md


https://gitlab.haskell.org/ghc/ghc/-/wikis/building/using
https://gitlab.haskell.org/ghc/ghc/-/wikis/contributing
https://gitlab.haskell.org/ghc/ghc/-/wikis/building#building-and-porting-ghc



** Haskell Cabal and Cross Compilation of Libraries
   https://log.zw3rk.com/posts/2017-05-19-ghc-s-cross-compilation-pipeline/
*** Cabal Cross Compilation
https://log.zw3rk.com/posts/2017-05-17-the-haskell-cabal-and-cross-compilation/
cabal will use a non-prefixed toolchain, which results in the library being compiled for the build machine.

cabal provides the cnecessary arguments to pass in the toolchain.

--builddir=dist/arm-linux-gnueabihf

--with-ghc=arm-linux-gnueabihf-ghc
--with-ghc-pkg=arm-linux-gnueabihf-ghc-pkg
--with-gcc=arm-linux-gnueabihf-clang
--with-ld=arm-linux-gnueabihf-ld
--hsc2hs-options=--cross-compile

--configure-option=--host=arm-linux-gnueabihf

https://github.com/ghc-ios/ghc-ios-scripts

** GHC and Libraries
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate_compilation.html
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/shared_libs.html
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html hsc2hs
** Nix Flakes
https://www.tweag.io/blog/2021-12-20-nix-2.4/
*** Part 1
https://www.tweag.io/blog/2020-05-25-flakes/

Original Nix expressions can access
- arbitrary files, e.g ~/.config/nixpkgs/config.nix
- environment variables
- git repositories
- files in Nix search path $NIX_PATH
- command-line arguments --arg
- and the system type builtins.currentSystem

No standard way to compose nix based projects.
Typical ways to compose Nix files rely on Nix search path
- e.g import <nixpkgs> or use fetchGit or fetchTarball
  - poor reproducabilty and and bad user experience due to usage of git hashes

No easy way to deliver Nix-based projects to users.
Nix has a 'channel' mechanism, but it's not easy to create channels and they are not composable.

Nix projects lack standardised structure.
- there are conventions e.g shell.nix or release.nix
  - but dont cover many common use cases
    - no way to discover NixOS modules provided by repository

Flake is the solution

Flake is just a source tree. e.g git repository
- containing a file named flake.nix
  - provides standardized interface to Nix artifacts
    - such as
      - packages
      - NixOS modules

Flakes can have deps on other flakes
- With a lock file pinning those deps to exact revs

**** Using Flakes
https://github.com/edolstra/dwarffs
it is a flake because it contains a file names flake.nix
- it tells nix what the flake provides
  - Such as 
    - Nix packages
    - NixOS modules
    - CI tests

** Bulding a Cross Compiler
   - Scan which resources and blog posts would be useful.
     - Can try summarise the zw3rk blog updates. https://log.zw3rk.com/       
*** zw3rk Blog
**** 2021
     https://log.zw3rk.com/posts/2021-06-28-off-by-one/
     - Story about static linker for Mach-O file format on AArch64.
**** 2018
***** Q1 Jan - March
     https://log.zw3rk.com/posts/2018-01-09-what-is-new-in-cross-compiling-haskell/
     - Talks about providing cross compiler binaires on hackage.mobilehaskell.org
     
     https://log.zw3rk.com/posts/2018-01-12-talk-building-android-apps-with-haskell/
     - Talk about building Android apps with Haskell.
     
     https://log.zw3rk.com/posts/2018-01-17-provisioning-a-nixos-server-from-macos/
     - Talks about hosting hackage.mobilehaskell.org
     - Talks changes in https://github.com/mobilehaskell/hackage-overlay being reflected in hackage.mobilehaskell.org
     - Bulding on some build machine, and then uploading to the server.
       
     https://log.zw3rk.com/posts/2018-02-05-what-is-new-in-cross-compiling-haskell/
     - Talks overlays in the repo being reflected in the server.
     - Talks about writing a patch/fix for cabal so that it works better for cross-compilation
       - So that it propagates the --with-PROG flags into dependencies.
	 - This must be things like:
	   --with-ghc=arm-linux-gnueabihf-ghc
           --with-ghc-pkg=arm-linux-gnueabihf-ghc-pkg
           --with-gcc=arm-linux-gnueabihf-clang
           --with-ld=arm-linux-gnueabihf-ld
     - Talks about SLURP and Uncurated Hackage Layer
       
     https://log.zw3rk.com/posts/2018-03-02-what-is-new-in-cross-compiling-haskell/
     - Talks about cabal --with-PROG file properly respected when using new-build
     - Talks about working for IOHK
       - Assisting DevOps team Cross Compile Haskell with GHC
	 - From Windows to Linux
       - Says will broaden and improve GHC's cross compilation capabilites.

     - Talks about being on a good road getting all sorted in GHC 8.6
     - Hopes that GHC 8.6 can be built by default with the shake based build system
       - hadrian will have extenseive cross compilation capabilites for various platforms.
     - Talks about work done making haskell cross compile from linux to windows:
       - https://twitter.com/angerman_io/status/969546657141420032	 
     
     https://log.zw3rk.com/posts/2018-03-14-talk-case-study-cross-compiling-dhall-json/
     - Gave a talk about how to cross compile dhall-json to raspberry pi.
       - Cross compile non trivial haskell packages and that issues such as
	 - ghc-head
	 - build-type
	 - Template Haskell
       - Have mostly trivial fixes of which most can be upstreamed.
     - Talk coincided with release of GHC 8.4 and release of new zlib package to hackage.
       - renders the fix to zlib unnecessary
     - Fix for contravarient crude.
       
***** Q2 April - June
     https://log.zw3rk.com/posts/2018-05-03-what-is-new-in-cross-compiling-haskell/
     - Talks about finished hadrian PRs
       - Now can build relocatable GHCs with hadrian by default.

     - Windows compilation can now be done via WINE
       - Don't need windows installation with iserv
       - Just run iserv via WINE

     - Talks about working with nix and limitations with respect to cross compilation.
       - Specifically flattening of conditionals (os/arch/flags) that cabal2nix does.
	 - This resulted in new tooling:
	   - https://github.com/input-output-hk/nix-tools
	   - https://github.com/angerman/haskell.nix
	   - https://github.com/input-output-hk/hackage.nix
	   - https://github.com/input-output-hk/stackage.nix
       - Will expand on this later.
     - Looked into adding -target to GHC.
       - Says very long road
       - Not only changes to GHC but also to build system, to build relevant libraries in the right places
	 - As well as to the tooling around
     
     https://log.zw3rk.com/posts/2018-06-06-what-is-new-in-cross-compiling-haskell/
     - Talks about fixing load command size limit on macOS

     - Spent more time looking at -target but nothing useful to report yet.
     - Started looking on the llvm-ng backend, making it ready for the ghc 8.6.1 release.
       - Included adapting new code gen paths for new primops in 8.6.1
     - Trying to speedup llvm-ng backend
     - Hope to provide prebuilt cross compiler binaries for 8.6.1
       
     - release of obelisk
***** Q3 July - September
     https://log.zw3rk.com/posts/2018-07-04-what-is-new-in-cross-compiling-haskell/
     - Adpating the llvm-ng backend to build a fresh set of pre-built 8.6.1 cross compilers.
     
     https://log.zw3rk.com/posts/2018-08-14-what-is-new-in-cross-compiling-haskell/
     - Playing with -target
       - Believes that best solution is to have minmimal ghc that doesn't ship with any libs.
         - All libs should be built on demand per target.
	 - Likely want to pre-build and ship the Runtime System Library rts as do not have cabal package that would build the rts.
	   - Would need partial target toolchain to build the rts for all the bundled rtss to be shipped.

     - Other side, likely want to use iserv e.g the -fexternal-interpreter
       - Run into some strange behaviour while compiling test-suite packages
	 - iserv complains code loaded multiple times.
	 - exploring how to get proper test-coverage for libraries
	   - even ghc in a cross compiled setting

     - Fixed -staticlib argument doesn't fail if object files in the archives it's trying to concat are odd-length
       - GHC doesn't panic anymore when -jN, N>1 is used and it fails to find/load a library.
	 
     - llvmng code to work with ghc8.6, retraced performance imporovement
     - Use aws compute time to build cross compiler once the final 8.6.1 hits. (must be talking about windoes here)

***** Q4 Oct - Dec
     https://log.zw3rk.com/posts/2018-10-09-what-is-new-in-cross-compiling-haskell/
     - llvm-ng, cmm, custom ghc, dump cmm
       - decoupling code generator end ghc front end
     - Usually
       - GHC reads file
       - Turns into AST
       - Desugares
       - Runs Optimizations
       - Turns into STG
       - Turns into cmm
     - so far cmm wasn't binary serilaizable
       - had to plug code generator in ghc
	 - and have frontend run
	   - then call code gen
     - talks about minimalst ghc, ghc should be packaged with:
       - rts
       - ghc
       - ghc-prim
       - integer-gmp
       - integer-simple
       - base
       - array
       - deepest
     - which means Cabal needs to be bootstrapped
     - prefer to get rid of template-haskell
       - however ghc is linked against it
       - not shipping and reinstalling different, would potentially break things depending on TH
     - a way around, to use external interpreter only
       - could recompile external interpreter against your changed TH library.
	 
     - ghc will likely ignore {-# ANN ... "HLint: ... #-} and provide {-# HLINT ... #-} pragma.

     - would like to get minimal ghc dist working for -target first
**** 2017
***** Q2 April - June
      https://log.zw3rk.com/posts/2017-04-20-hello-world-and-a-cross-compilation-survey/
      Survey

      https://log.zw3rk.com/posts/2017-05-03-building-iconv-for-android/
      check <-
      
      https://log.zw3rk.com/posts/2017-05-09-cross-compilation-survey-results/
      Survey

      https://log.zw3rk.com/posts/2017-05-10-quick-headless-raspberry-pi-setup/

      https://log.zw3rk.com/posts/2017-05-11-making-a-raspbian-cross-compilation-sdk/

      https://log.zw3rk.com/posts/2017-05-16-a-haskell-cross-compiler-for-raspberry-pi/

      https://log.zw3rk.com/posts/2017-05-17-the-haskell-cabal-and-cross-compilation/

      https://log.zw3rk.com/posts/2017-05-18-why-use-a-cross-compiler/
      Why use cross compiler

      https://log.zw3rk.com/posts/2017-05-19-ghc-s-cross-compilation-pipeline/
      check <-

      https://log.zw3rk.com/posts/2017-05-23-template-haskell/
      th <- 
      
      https://log.zw3rk.com/posts/2017-05-24-template-haskell-and-cross-compilation/
      th <- 

      https://log.zw3rk.com/posts/2017-05-25-cross-compiling-template-haskell/
      th <-

      - GHCs external interpreter, splits ghc into 2 components
	- ghc
	- interpreter server iserv
      - Passing -fexternal-interpreter to ghc will spawn an iserv instance and run interpreted code through it.
      - ghc instruct iserv to load and link libraries as needed, and eval bytecode objects.
      - iserv can query ghc for current compilation env during eval.

      - split iserv into two parts
	- iserv-proxy , serves as iserv interface to GHC on the build machine.
	- GHCSlave , on the target machine

      - first need a cross compiler

      - Building iserv
	- iserv-proxy is built with the build machine ghc as it runs on the build machine
	- iserv-bin, which contains iserv-proxy of the ghc tree can be found in iserv subfolder of ghc
	  
      
      https://log.zw3rk.com/posts/2017-05-27-cross-compiling-yesod-to-raspberry-pi/

      https://log.zw3rk.com/posts/2017-05-30-a-haskell-cross-compiler-for-android/
      check <- 

      https://log.zw3rk.com/posts/2017-05-31-android-and-template-haskell/
      th <- 

      https://log.zw3rk.com/posts/2017-06-02-what-is-new-in-cross-compiling-haskell/
      This contains some highlights and summaries.

      https://log.zw3rk.com/posts/2017-06-06-a-haskell-cross-compiler-for-ios/
      check <- 

      https://log.zw3rk.com/posts/2017-06-07-ios-and-template-haskell/
      th <-

      - Wrap GHCSlave (remote iserv) instance into an application for iOS.
      - Build the GHCSlave iOS application with the iOS cross compiler.

      - Build iserv-proxy. -> this is to run on the build machine

      - Build iserv library. -> this is to run on the target machine
	- ghc/iserv $ aarch64-apple-ios-cabal install -flibrary
        - ghc/iserv $ x86_64-apple-ios-cabal install -flibrary
      - clone the cross compiler ghc version, need donwload that source distribution

      - Need to build stati library and wrap it into a native iOS app.
	- Code for the slave app can be found in the iOS folder of ghc-slave
#+begin_src sh
  aarch64-apple-ios-ghc -odir arm64 -hidir arm64 -staticlib -threaded -lffi -L/path/to/libffi/aarch64-apple-ios/lib -o hs-libs/arm64/libhs.a -package iserv-bin hs/LineBuff.hs
  x86_64-apple-ios-ghc -odir x86_64 -hidir x86_64 -staticlib -threaded -lffi -L/path/to/libffi/x86_64-apple-ios/lib -o hs-libs/x86_64/libhs.a -package iserv-bin hs/LineBuff.hs
  lipo -create -output hs-libs/libhs.a hs-libs/arm64/libhs.a hs-libs/x86_64/libhs.a
  # we need -threaded as the startSlave function calls forkIO to start the slave in a separate thread
#+end_src
***** Q3 July - September
      https://log.zw3rk.com/posts/2017-07-06-what-is-new-in-cross-compiling-haskell/
      Some summary

      https://log.zw3rk.com/posts/2017-08-03-what-is-new-in-cross-compiling-haskell/
      Figuring out how to buld distirbutable binaries of GHC cross compilers

      https://log.zw3rk.com/posts/2017-09-05-what-is-new-in-cross-compiling-haskell/
      - Bulding llvm backend, integrating llvm bitcode backend into ghc.
      - -fllvmng backend can compile GHC, but fails to validate
***** Q4 Oct - Dec
      https://log.zw3rk.com/posts/2017-10-08-what-is-new-in-cross-compiling-haskell/
      - ICFP, cross compilation diffs merged
      - Q monad extension for TH ajdustments
      - announcement of head.hackage overlay
	- allows to have set of patches which are turned into separate hackage repo
	- patches picked from repo rather than from upstream hackage repo if a patched package exists
	- hackage overlay patches the packages on the server side and provide separate hackage repo
	  - which takes prescedence over the upstream hackage repo
      - built hackage.mobilehaskell.org
	- so far a single patched package, zlib
	- https://github.com/mobilehaskell/hackage-overlay
        - also contains jexperimental ghc binary dists, built with llvmng llvm backend
	  

      https://log.zw3rk.com/posts/2017-10-20-ghc-cross-compiler-binary-distributions/
      <- check (outdated using make?)

      https://log.zw3rk.com/posts/2017-10-30-building-ghc-the-package-database/
      ghc's build system and ghc-pkg

      https://log.zw3rk.com/posts/2017-11-11-what-is-new-in-cross-compiling-haskell/
      - ghc 8.4.1 is comming
        - come with a shake based build system called hadrian
	- make based build system will eventually be dropped.

      - after investigating make, bit the bullet and went with hadrian

      - gonna write about GHCs build system

      - ideal cross compiler contains a bin and lib folder, simply unpacking and running bin/ghc.
	- requires the distribution is relocatable.
      - to achieve this, would be great if the build system would place the package database relocateable into lib and the binaries into bin
      - created a fat PR into hadrian to make it possible
	

      https://log.zw3rk.com/posts/2017-11-11-building-ghc-the-tools/
      <- check -- tools to build GHC
      
      https://log.zw3rk.com/posts/2017-11-22-building-ghc-the-stages/
      <- check -- GHC build stages

      https://log.zw3rk.com/posts/2017-12-08-what-is-new-in-cross-compiling-haskell/
      - was workingon hadrian fork to allow building relocatable binary distributions for GHC, specifically for cross compilers
      - will update hackage.mobilehaskell.org with these builds
      - alp mestangullari taking over branch, hoping merge chunks of branch into upstream hadrian

      https://log.zw3rk.com/posts/2017-12-20-relocatable-ghc-cross-compiler-binary-distributions/
      <- check -- talk about relocatable binary dist

      https://log.zw3rk.com/posts/2017-12-21-contributing-to-ghc/
      contributing to ghc
      

      

** The toolchain wrappers
https://github.com/zw3rk/toolchain-wrapper <- most recently commited to
https://github.com/ghc-ios/ghc-ios-scripts 
*** toolchain-wrapper / ghc iOS scripts
- ghc iOS scripts talks about the stubs.

- So these are mainly intended for iOS, but toolchain-wrapper has stuff for
  - RaspberryPi (arm-linux-gnueabihf)
  - Android (armv7-linux-anroideabi, aarch64-linux-android)
  - iOS (x86_64-apple-ios, aarch64-apple-ios)

- Wrapped commands are:
  - gcc
  - clang
  - ld
  - ld.gold
  - nm
  - ar
  - ranlib
  - cabal

- xcode is a dependency


- wrapper is the core script
  - it reads its own program name (command, and target) and maps them to the (command and arguments)
#+begin_src sh
targets="arm-linux-gnueabihf x86_64-linux-android armv7-linux-androideabi aarch64-linux-android x86_64-apple-ios aarch64-apple-ios wasm32-unknown-unknown-wasm aarch64-apple-darwin arm64-apple-darwin"
commands="clang ld ld.gold nm ar ranlib cabal llvm-dis llvm-nm llvm-ar"
#+end_src    
- boostrap creates program names and symlinks them to the wrapper


When the command name matches cabal:
#+begin_src sh
  ,*-cabal)
	  fcommon="--builddir=dist/${target}"
	  fcompile=" --with-ghc=${target}-ghc"
	  fcompile+=" --with-ghc-pkg=${target}-ghc-pkg"
	  fcompile+=" --with-gcc=${target}-clang"
	  fcompile+=" --with-ld=${target}-ld"
	  fcompile+=" --with-hsc2hs=${target}-hsc2hs"
	  fcompile+=" --hsc2hs-options=--cross-compile"
	  fconfig="--disable-shared --configure-option=--host=${target}"
	  case $1 in
	      configure|install) flags="${fcommon} ${fcompile} ${fconfig}" ;;
	      build)             flags="${fcommon} ${fcompile}" ;;
	      new-configure|new-install) flags="${fcompile} ${fconfig}" ;;
	      new-build)         flags="${fcompile}" ;;
	      list|info|update)  flags="" ;;
	      "")                flags="" ;;
	      *)                 flags=$fcommon ;;
	  esac;;
#+end_src

When the command matches hsc2hs:
#+begin_src sh
*-hsc2hs) flags=" --cross-compile" ;;
#+end_src

When the command matches various apples:
#+begin_src sh
  # iOS -- this us run though apples xcrun tool.

  aarch64-apple-ios-clang|aarch64-apple-ios-ld)
	  flags="--sdk iphoneos ${cmd} -arch arm64"
	  cmd="xcrun" ;;

  aarch64-apple-ios-*|aarch64-apple-ios-*)
	  flags="--sdk iphoneos ${cmd}"
	  cmd="xcrun" ;;

  # iOS (64bit simulator)
  x86_64-apple-ios-clang|x86_64-apple-ios-ld)
	  flags="--sdk iphonesimulator ${cmd} -arch x86_64"
	  cmd="xcrun" ;;

  x86_64-apple-ios-*)
	  flags="--sdk iphonesimulator ${cmd}"
	  cmd="xcrun" ;;


  # looks like these are not for the phone
  aarch64-apple-darwin-clang|aarch64-apple-darwin-ld|arm64-apple-darwin-clang|arm64-apple-darwin-ld)
	  flags="--sdk macosx ${cmd} -arch arm64"
	  cmd="xcrun" ;;

  aarch64-apple-darwin-*|arm64-apple-darwin-*)
	  flags="--sdk macosx ${cmd}"
	  cmd="xcrun" ;;
#+end_src

When the command matches llvm
#+begin_src sh
 *-llvm-*|wasm32-*-nm|wasm32-*-ar|wasm32-*-ranlib) cmd="llvm-$cmd" ;;
#+end_src

When the command matches the other tools:
#+begin_src sh
# they retain their original cmd and flags
*-nm|*-ar|*-ranlib) ;;
#+end_src

For all apples, it just runs the command:
#+begin_src sh
*) exec $cmd $flags "$@" ;;
#+end_src

$@ refers to all the scripts command line arguments


https://github.com/ghc-ios/ghc-ios-scripts/blob/master/ghc-ios
Shows some examples of the flags used with the ghc's
** XCode in Nix
http://sandervanderburg.blogspot.com/2012/12/deploying-ios-applications-with-nix.html
https://github.com/NixOS/nixpkgs/tree/master/pkgs/os-specific/darwin
https://github.com/NixOS/nixpkgs/blob/release-21.11/pkgs/top-level/darwin-packages.nix
https://github.com/svanderburg/nix-xcodeenvtests
#+begin_src sh
lrwxr-xr-x  1 sander  staff  94  1 jan  1970 Simulator -> /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app/Contents/MacOS/Simulator
lrwxr-xr-x  1 sander  staff  17  1 jan  1970 codesign -> /usr/bin/codesign
lrwxr-xr-x  1 sander  staff  17  1 jan  1970 security -> /usr/bin/security
lrwxr-xr-x  1 sander  staff  21  1 jan  1970 xcode-select -> /usr/bin/xcode-select
lrwxr-xr-x  1 sander  staff  61  1 jan  1970 xcodebuild -> /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild
lrwxr-xr-x  1 sander  staff  14  1 jan  1970 xcrun -> /usr/bin/xcrun 
#+end_src

** Cabal management
https://stackoverflow.com/questions/25765893/how-do-i-install-dependencies-when-cross-compiling-haskell-code
